#[cfg(feature = "python")]
pub mod py;

use super::{abaqus::Abaqus, exodus::Exodus};
use chrono::Utc;
use itertools::Itertools;
use std::{
    fs::File,
    io::{BufWriter, Write},
};

const ELEMENT_TYPE: &str = "C3D8R";

pub type ElementBlocks = Vec<usize>;
pub type ElementConnectivity = Vec<Vec<usize>>;
pub type NodalCoordinates = Vec<Vec<f64>>;

/// The finite elements type.
pub struct FiniteElements {
    element_blocks: ElementBlocks,
    element_connectivity: ElementConnectivity,
    nodal_coordinates: NodalCoordinates,
}

/// Inherent implementation of the finite elements type.
impl FiniteElements {
    /// Constructs and returns a new Exodus type from data.
    pub fn from_data(
        element_blocks: ElementBlocks,
        element_connectivity: ElementConnectivity,
        nodal_coordinates: NodalCoordinates,
    ) -> Self {
        Self {
            element_blocks,
            element_connectivity,
            nodal_coordinates,
        }
    }
    /// Returns a reference to the element blocks.
    pub fn get_element_blocks(&self) -> &ElementBlocks {
        &self.element_blocks
    }
    /// Returns a reference to the element connectivity.
    pub fn get_element_connectivity(&self) -> &ElementConnectivity {
        &self.element_connectivity
    }
    /// Returns a reference to the nodal coordinates.
    pub fn get_nodal_coordinates(&self) -> &NodalCoordinates {
        &self.nodal_coordinates
    }
}

/// Abaqus implementation of the finite elements type.
impl Abaqus for FiniteElements {
    fn write_inp(&self, file_path: &str) {
        write_fem_to_inp(
            file_path,
            self.get_element_blocks(),
            self.get_element_connectivity(),
            self.get_nodal_coordinates(),
        )
    }
}

/// Exodus implementation of the finite elements type.
impl Exodus for FiniteElements {
    fn write_exo(&self, _file_path: &str) {
        todo!("Writing Exodus files has not yet been implemented.")
    }
}

fn write_fem_to_inp(
    file_path: &str,
    element_blocks: &ElementBlocks,
    element_connectivity: &ElementConnectivity,
    nodal_coordinates: &NodalCoordinates,
) {
    let element_number_width = get_width(element_connectivity);
    let node_number_width = get_width(nodal_coordinates);
    let inp_file = File::create(file_path).expect("Could not create the .inp file.");
    let mut file = BufWriter::new(inp_file);
    write_heading_to_inp(&mut file);
    write_nodal_coordinates_to_inp(&mut file, nodal_coordinates, &node_number_width);
    write_element_connectivity_to_inp(
        &mut file,
        element_blocks,
        element_connectivity,
        &element_number_width,
        &node_number_width,
    );
    file.flush().expect("Forgot to flush!");
}

fn write_heading_to_inp(file: &mut BufWriter<File>) {
    let heading = format!(
        "*HEADING\nautotwin.automesh\nversion {}\nautogenerated on {}",
        env!("CARGO_PKG_VERSION"),
        Utc::now()
    );
    file.write_all(heading.as_bytes()).unwrap();
    end_section(file);
}

fn write_nodal_coordinates_to_inp(
    file: &mut BufWriter<File>,
    nodal_coordinates: &NodalCoordinates,
    node_number_width: &usize,
) {
    file.write_all("*NODE, NSET=ALLNODES".as_bytes()).unwrap();
    nodal_coordinates
        .iter()
        .enumerate()
        .for_each(|(node, coordinates)| {
            indent(file);
            file.write_all(format!("{:>width$}", node + 1, width = node_number_width).as_bytes())
                .unwrap();
            coordinates.iter().for_each(|coordinate| {
                delimiter(file);
                file.write_all(format!("{:>15.6e}", coordinate).as_bytes())
                    .unwrap();
            });
        });
    end_section(file);
}

fn write_element_connectivity_to_inp(
    file: &mut BufWriter<File>,
    element_blocks: &ElementBlocks,
    element_connectivity: &ElementConnectivity,
    element_number_width: &usize,
    node_number_width: &usize,
) {
    element_blocks.iter().unique().for_each(|current_block| {
        file.write_all(
            format!("*ELEMENT, TYPE={}, ELSET=EB{}", ELEMENT_TYPE, current_block).as_bytes(),
        )
        .unwrap();
        element_blocks
            .iter()
            .enumerate()
            .filter(|(_, block)| block == &current_block)
            .for_each(|(element, _)| {
                indent(file);
                file.write_all(
                    format!("{:>width$}", element + 1, width = element_number_width).as_bytes(),
                )
                .unwrap();
                element_connectivity[element].iter().for_each(|entry| {
                    delimiter(file);
                    file.write_all(
                        format!("{:>width$}", entry, width = node_number_width + 3).as_bytes(),
                    )
                    .unwrap();
                });
            });
        end_section(file);
    });
    element_blocks.iter().unique().for_each(|block| {
        file.write_all(
            format!(
                "*SOLID SECTION, ELSET=EB{}, MATERIAL=Default-Steel\n",
                block
            )
            .as_bytes(),
        )
        .unwrap()
    });
}

fn end_section(file: &mut BufWriter<File>) {
    file.write_all(&[10, 42, 42, 10]).unwrap()
}

fn delimiter(file: &mut BufWriter<File>) {
    file.write_all(&[44, 32]).unwrap()
}

fn indent(file: &mut BufWriter<File>) {
    file.write_all(&[10, 32, 32, 32, 32]).unwrap()
}

fn get_width<T>(input: &[T]) -> usize {
    input.len().to_string().chars().count()
}
